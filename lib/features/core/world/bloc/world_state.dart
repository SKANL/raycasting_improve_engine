part of 'world_bloc.dart';

/// Represents the complete state of the game world.
///
/// This is the single source of truth for all world data.
/// All renderers (3D, 2D, Isometric) read from this state.
class WorldState extends Equatable {
  const WorldState({
    this.status = WorldStatus.initial,
    this.map,
    this.mapTexture,
    this.textureAtlas,
    this.spriteAtlas,
    this.weaponAtlas,
    this.entities = const [],
    this.lights = const [],
    this.playerPosition,
    this.playerDirection = 0.0,
    this.time = 0.0,
    this.effects = const [],
    this.playerHealth = 100,
    this.playerMaxHealth = 100,
    this.isPlayerDead = false,
    this.projectiles = const [],
    this.playerInvulnerabilityTime = 0.0,
  });

  /// Creates an empty initial state.
  factory WorldState.empty() => const WorldState();

  /// Current status of the world.
  final WorldStatus status;

  /// The game map grid.
  final GameMap? map;

  /// Packed RGBA texture of the map for shader consumption.
  final ui.Image? mapTexture;

  /// Procedural texture atlas (walls, floors).
  final ui.Image? textureAtlas;

  /// Procedural sprite atlas (enemies, items).
  final ui.Image? spriteAtlas;

  /// Procedural weapon atlas (view models).
  final ui.Image? weaponAtlas;

  /// All entities in the world (enemies, items, NPCs).
  final List<GameEntity> entities;

  /// All light sources in the world.
  final List<LightSource> lights;

  /// Player position in world coordinates.
  final Vector2? playerPosition;

  /// Player facing direction in radians.
  final double playerDirection;

  /// Elapsed game time for shader animations.
  final double time;

  /// Pending effects to be consumed by the game loop.
  final List<WorldEffect> effects;

  /// Current player health points.
  final int playerHealth;

  /// Maximum player health points.
  final int playerMaxHealth;

  /// Whether the player is dead (triggers game-over).
  final bool isPlayerDead;

  /// Active projectiles in the world (bouncing bullets, enemy shots).
  final List<Projectile> projectiles;

  /// Time in seconds remaining for player invulnerability.
  final double playerInvulnerabilityTime;

  /// Default spawn position if playerPosition is null.
  static final _defaultPosition = Vector2(1.5, 1.5);

  /// Returns player position, defaulting to spawn point if null.
  Vector2 get effectivePosition => playerPosition ?? _defaultPosition;

  /// Creates a copy with optional overrides.
  WorldState copyWith({
    WorldStatus? status,
    GameMap? map,
    ui.Image? mapTexture,
    ui.Image? textureAtlas,
    ui.Image? spriteAtlas,
    ui.Image? weaponAtlas,
    List<GameEntity>? entities,
    List<LightSource>? lights,
    Vector2? playerPosition,
    double? playerDirection,
    double? time,
    List<WorldEffect>? effects,
    int? playerHealth,
    int? playerMaxHealth,
    bool? isPlayerDead,
    List<Projectile>? projectiles,
    double? playerInvulnerabilityTime,
  }) {
    return WorldState(
      status: status ?? this.status,
      map: map ?? this.map,
      mapTexture: mapTexture ?? this.mapTexture,
      textureAtlas: textureAtlas ?? this.textureAtlas,
      spriteAtlas: spriteAtlas ?? this.spriteAtlas,
      weaponAtlas: weaponAtlas ?? this.weaponAtlas,
      entities: entities ?? this.entities,
      lights: lights ?? this.lights,
      playerPosition: playerPosition ?? this.playerPosition,
      playerDirection: playerDirection ?? this.playerDirection,
      time: time ?? this.time,
      effects: effects ?? this.effects,
      playerHealth: playerHealth ?? this.playerHealth,
      playerMaxHealth: playerMaxHealth ?? this.playerMaxHealth,
      isPlayerDead: isPlayerDead ?? this.isPlayerDead,
      projectiles: projectiles ?? this.projectiles,
      playerInvulnerabilityTime:
          playerInvulnerabilityTime ?? this.playerInvulnerabilityTime,
    );
  }

  @override
  List<Object?> get props => [
    status,
    map,
    mapTexture,
    textureAtlas,
    spriteAtlas,
    weaponAtlas,
    entities,
    lights,
    playerPosition,
    playerDirection,
    time,
    effects,
    playerHealth,
    playerMaxHealth,
    isPlayerDead,
    projectiles,
    playerInvulnerabilityTime,
  ];
}

/// Status of the world simulation.
enum WorldStatus {
  /// World has not been initialized yet.
  initial,

  /// World is being generated.
  loading,

  /// World is active and running.
  active,

  /// World simulation is paused.
  paused,

  /// Game Over state (player died).
  gameOver,
}

/// One-shot effects generated by the world (e.g. sounds, damage).
sealed class WorldEffect {
  const WorldEffect();
}

/// Effect: Player takes damage.
class PlayerDamagedEffect extends WorldEffect {
  const PlayerDamagedEffect(
    this.amount, {
    this.lifetime = 2.0,
    this.maxLifetime = 2.0,
  });
  final int amount;

  /// Remaining lifetime in seconds (default 2.0s fading).
  final double lifetime;

  /// Total lifetime for percentage calculations.
  final double maxLifetime;

  /// Returns intensity from 1.0 (start) to 0.0 (end) using ease-out curve.
  double get intensity {
    final t = (maxLifetime - lifetime) / maxLifetime;
    // Ease-out cubic for a fast initial flash that fades slowly
    return 1.0 - (t * t * t);
  }
}

/// Effect: Player killed an enemy.
class EnemyKilledEffect extends WorldEffect {
  const EnemyKilledEffect(this.entityId);
  final String entityId;
}

/// Effect: A projectile hit something and spawned a decal.
class ProjectileHitEffect extends WorldEffect {
  const ProjectileHitEffect({required this.position, required this.isEnemy});
  final Vector2 position;
  final bool isEnemy;
}

/// Effect: A bouncing projectile reflected off a wall at [position].
class BounceEffect extends WorldEffect {
  const BounceEffect(this.position);
  final Vector2 position;
}

/// Effect: A non-bouncing projectile hit a wall â€” spawn a bullet decal.
class WallHitEffect extends WorldEffect {
  const WallHitEffect(this.position);
  final Vector2 position;
}

/// Effect: Player walked over an ammo pickup.
class AmmoPickedUpEffect extends WorldEffect {
  const AmmoPickedUpEffect({required this.ammoType, required this.quantity});
  final AmmoType ammoType;
  final int quantity;
}
